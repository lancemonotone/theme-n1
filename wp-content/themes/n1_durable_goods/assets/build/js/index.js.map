{"version":3,"file":"index.js","sources":["../../src/js/class.accordion.js","../../src/js/class.header.js"],"sourcesContent":["window.addEventListener('load', function() {\r\n  const containers = document.querySelectorAll('.accordion')\r\n\r\n  containers.forEach(container => {\r\n    new ClassAccordion(container)\r\n  })\r\n})\r\n\r\n// transform toggleAriaExpanded into a class\r\nclass ClassAccordion {\r\n  constructor(container, focus = false) {\r\n    this.focus = focus\r\n    this.container = container\r\n    this.toggle = container.querySelector('.toggle')\r\n    this.content = container.querySelector('.toggle-section')\r\n    this.button = container.querySelector('.toggle-label')\r\n    this.init()\r\n  }\r\n\r\n  findFirstFocusableElement(parentElement) {\r\n    const focusableElementsSelector = 'a[href], button:not([disabled]), textarea:not([disabled]), input:not([type=submit]):not([disabled]), select:not([disabled]), [tabindex]:not([tabindex=\"-1\"])'\r\n    const focusableElements = parentElement.querySelectorAll(focusableElementsSelector)\r\n    const visibleFocusableElements = Array.from(focusableElements).\r\n                                           filter(el => el.offsetWidth > 0 && el.offsetHeight > 0)\r\n    return visibleFocusableElements.length > 0 ? visibleFocusableElements[0] : null\r\n  }\r\n\r\n  init() {\r\n    this.toggle.addEventListener('change', () => {\r\n      if (this.toggle.checked) {\r\n        // if the accordion is expanded\r\n        this.toggle.setAttribute('aria-expanded', 'true')\r\n        // Find the first focusable element in the expanded content and focus it\r\n        if (this.focus) {\r\n          let firstFocusableElement = this.findFirstFocusableElement(this.content)\r\n          if (firstFocusableElement) {\r\n            firstFocusableElement.focus()\r\n          }\r\n        }\r\n      } else {\r\n        // if the accordion is collapsed\r\n        this.toggle.setAttribute('aria-expanded', 'false')\r\n        // Return focus back to the button\r\n        this.button.focus()\r\n      }\r\n    })\r\n  }\r\n}\r\n","(function () {\r\n    const element = document.getElementById('site-header')\r\n    if (!element) {\r\n        console.error('Element with ID \\'site-header\\' not found.')\r\n        return\r\n    }\r\n\r\n    const body = document.body\r\n    const documentElement = document.documentElement\r\n\r\n    const style = getComputedStyle(element)\r\n\r\n    let initialHeight = style.getPropertyValue('--header-max-height').trim()\r\n    if (initialHeight === 'auto') {\r\n        initialHeight = element.clientHeight\r\n    } else if (initialHeight.endsWith('rem')) {\r\n        initialHeight = parseFloat(initialHeight) * parseFloat(getComputedStyle(document.documentElement).fontSize)\r\n    } else {\r\n        console.error('Unsupported value for --header-max-height: ', initialHeight)\r\n        return\r\n    }\r\n\r\n    // Define a buffer zone around initialHeight\r\n    const bufferZone = 10  // 10 pixels as an example, you can adjust this value\r\n\r\n    element.style.paddingBlock = 'var(--header-max-padding-block)'\r\n\r\n    let lastScrollTop = 0\r\n    let throttleTimeout\r\n\r\n    window.addEventListener('scroll', () => {\r\n        if (throttleTimeout) {\r\n            return\r\n        }\r\n\r\n        throttleTimeout = setTimeout(() => {\r\n            throttleTimeout = null\r\n\r\n            const scrollTop = body.scrollTop > documentElement.scrollTop ? body.scrollTop : documentElement.scrollTop\r\n\r\n            // Check if scrollTop is within the buffer zone\r\n            if (Math.abs(scrollTop - initialHeight) <= bufferZone) {\r\n                return\r\n            }\r\n\r\n            if (scrollTop > initialHeight) {\r\n                element.style.paddingBlock = 'var(--header-min-padding-block)'\r\n            } else {\r\n                element.style.paddingBlock = 'var(--header-max-padding-block)'\r\n            }\r\n        }, 100)\r\n    })\r\n})()\r\n\r\n// (function () {\r\n//     const element = document.getElementById('site-header');\r\n//     const body = document.body;\r\n//\r\n//     // Get the value of the --header-max-height custom property\r\n//     const style = getComputedStyle(element);\r\n//     const initialHeight = parseInt(style.getPropertyValue('--header-max-height'), 10);\r\n//\r\n//     let isCollapsed = false;\r\n//\r\n//     window.addEventListener('scroll', () => {\r\n//         const scrollY = Math.floor(window.scrollY);\r\n//\r\n//         // Inform the browser that the height property will change, optimizing rendering\r\n//         element.style.willChange = 'height';\r\n//\r\n//         // Check if the user has scrolled down enough to trigger the animation\r\n//         if (scrollY >= initialHeight && !isCollapsed) {\r\n//             element.style.height = 'var(--header-min-height)';\r\n//             body.classList.add('header-collapsed'); // Add class to the body\r\n//             isCollapsed = true;\r\n//         } else if (scrollY < initialHeight && isCollapsed) {\r\n//             element.style.height = 'var(--header-max-height)';\r\n//             body.classList.remove('header-collapsed'); // Remove class from the body\r\n//             isCollapsed = false;\r\n//         }\r\n//\r\n//         // Optionally, you can reset willChange after the animation to release optimization resources\r\n//         // setTimeout(() => { element.style.willChange = 'auto'; }, 300);\r\n//     });\r\n// })();\r\n\r\n\r\n"],"names":["window","addEventListener","document","querySelectorAll","forEach","container","ClassAccordion","constructor","focus","this","toggle","querySelector","content","button","init","findFirstFocusableElement","parentElement","focusableElements","visibleFocusableElements","Array","from","filter","el","offsetWidth","offsetHeight","length","checked","setAttribute","firstFocusableElement","element","getElementById","console","error","body","documentElement","initialHeight","getComputedStyle","getPropertyValue","trim","clientHeight","endsWith","parseFloat","fontSize","throttleTimeout","style","paddingBlock","setTimeout","scrollTop","Math","abs"],"mappings":"2FAAOA,OAAAC,iBAAiB,QAAQ,WACXC,SAASC,iBAAiB,cAElCC,SAAqBC,IAC9B,IAAIC,EAAeD,EAAS,GAEhC,IAGA,MAAMC,EACJC,YAAYF,EAAWG,GAAQ,GAC7BC,KAAKD,MAAQA,EACbC,KAAKJ,UAAYA,EACZI,KAAAC,OAASL,EAAUM,cAAc,WACjCF,KAAAG,QAAUP,EAAUM,cAAc,mBAClCF,KAAAI,OAASR,EAAUM,cAAc,iBACtCF,KAAKK,MACN,CAEDC,0BAA0BC,GACxB,MACMC,EAAoBD,EAAcb,iBADN,gKAE5Be,EAA2BC,MAAMC,KAAKH,GACLI,QAAaC,GAAAA,EAAGC,YAAc,GAAKD,EAAGE,aAAe,IAC5F,OAAON,EAAyBO,OAAS,EAAIP,EAAyB,GAAK,IAC5E,CAEDJ,OACOL,KAAAC,OAAOT,iBAAiB,UAAU,KACjC,GAAAQ,KAAKC,OAAOgB,SAId,GAFKjB,KAAAC,OAAOiB,aAAa,gBAAiB,QAEtClB,KAAKD,MAAO,CACd,IAAIoB,EAAwBnB,KAAKM,0BAA0BN,KAAKG,SAC5DgB,GACFA,EAAsBpB,OAEzB,OAGIC,KAAAC,OAAOiB,aAAa,gBAAiB,SAE1ClB,KAAKI,OAAOL,OACb,GAEJ,GC9CH,WACU,MAAAqB,EAAU3B,SAAS4B,eAAe,eACxC,IAAKD,EAED,YADAE,QAAQC,MAAM,4CAIlB,MAAMC,EAAO/B,SAAS+B,KAChBC,EAAkBhC,SAASgC,gBAIjC,IAAIC,EAFUC,iBAAiBP,GAELQ,iBAAiB,uBAAuBC,OAClE,GAAsB,SAAlBH,EACAA,EAAgBN,EAAQU,iBACjB,KAAAJ,EAAcK,SAAS,OAI9B,YADQT,QAAAC,MAAM,8CAA+CG,GAF7CA,EAAAM,WAAWN,GAAiBM,WAAWL,iBAAiBlC,SAASgC,iBAAiBQ,SAIrG,CAQG,IAAAC,EAHJd,EAAQe,MAAMC,aAAe,kCAKtB7C,OAAAC,iBAAiB,UAAU,KAC1B0C,IAIJA,EAAkBG,YAAW,KACPH,EAAA,KAElB,MAAMI,EAAYd,EAAKc,UAAYb,EAAgBa,UAAYd,EAAKc,UAAYb,EAAgBa,UAG5FC,KAAKC,IAAIF,EAAYZ,IAlBd,KAuBPN,EAAQe,MAAMC,aADdE,EAAYZ,EACiB,kCAEA,kCAChC,GACF,KAAG,GAEV,CApDJ"}