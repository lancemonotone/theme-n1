{"version":3,"file":"index.js","sources":["../../src/js/class.accordion.js","../../src/js/class.header.js"],"sourcesContent":["window.addEventListener('load', function() {\r\n  const containers = document.querySelectorAll('.accordion')\r\n\r\n  containers.forEach(container => {\r\n    new ClassAccordion(container)\r\n  })\r\n})\r\n\r\n// transform toggleAriaExpanded into a class\r\nclass ClassAccordion {\r\n  constructor(container, focus = false) {\r\n    this.focus = focus\r\n    this.container = container\r\n    this.toggle = container.querySelector('.toggle')\r\n    this.content = container.querySelector('.toggle-section')\r\n    this.button = container.querySelector('.toggle-label')\r\n    this.init()\r\n  }\r\n\r\n  findFirstFocusableElement(parentElement) {\r\n    const focusableElementsSelector = 'a[href], button:not([disabled]), textarea:not([disabled]), input:not([type=submit]):not([disabled]), select:not([disabled]), [tabindex]:not([tabindex=\"-1\"])'\r\n    const focusableElements = parentElement.querySelectorAll(focusableElementsSelector)\r\n    const visibleFocusableElements = Array.from(focusableElements).\r\n                                           filter(el => el.offsetWidth > 0 && el.offsetHeight > 0)\r\n    return visibleFocusableElements.length > 0 ? visibleFocusableElements[0] : null\r\n  }\r\n\r\n  init() {\r\n    this.toggle.addEventListener('change', () => {\r\n      if (this.toggle.checked) {\r\n        // if the accordion is expanded\r\n        this.toggle.setAttribute('aria-expanded', 'true')\r\n        // Find the first focusable element in the expanded content and focus it\r\n        if (this.focus) {\r\n          let firstFocusableElement = this.findFirstFocusableElement(this.content)\r\n          if (firstFocusableElement) {\r\n            firstFocusableElement.focus()\r\n          }\r\n        }\r\n      } else {\r\n        // if the accordion is collapsed\r\n        this.toggle.setAttribute('aria-expanded', 'false')\r\n        // Return focus back to the button\r\n        this.button.focus()\r\n      }\r\n    })\r\n  }\r\n}\r\n","class Header {\r\n    constructor () {\r\n        this.resizeOperations = []\r\n        // Throttle scroll events to run at most once every 100ms\r\n        this.scrollHandler = this.throttle(this.handleScroll.bind(this), 100)\r\n    }\r\n\r\n    resizeOnScroll (targetSelector, propertyToResize, minSize, maxSize, maxScroll, easing = '0.1s cubic-bezier(1, -0.02, 1, 1)') {\r\n        let targetElement = document.querySelector(targetSelector)\r\n        let minSizeFloat = parseFloat(minSize)\r\n        let maxSizeFloat = parseFloat(maxSize)\r\n        let unit = maxSize.replace(maxSizeFloat.toString(), '')\r\n\r\n        if (targetElement) {\r\n            targetElement.style.transition = `${ propertyToResize } ${ easing }`\r\n            // Inform the browser that this element will animate\r\n            targetElement.style.willChange = propertyToResize\r\n            this.resizeOperations.push({\r\n                targetElement   : targetElement,\r\n                propertyToResize: propertyToResize,\r\n                minSize         : minSizeFloat,\r\n                maxSize         : maxSizeFloat,\r\n                unit            : unit,\r\n                maxScroll       : maxScroll,\r\n                easing          : easing,\r\n            })\r\n            window.addEventListener('scroll', this.scrollHandler)\r\n        }\r\n    }\r\n\r\n    handleScroll (event) {\r\n        // Request an animation frame to delay handling of the scroll event until the next repaint\r\n        window.requestAnimationFrame(() => {\r\n            let scrollPosition = window.scrollY || window.scrollTop || document.getElementsByTagName('html')[0].scrollTop\r\n            for (let operation of this.resizeOperations) {\r\n                let newSize = this.calculateSize(scrollPosition, operation.minSize, operation.maxSize, operation.maxScroll)\r\n                this.resize(newSize, operation)\r\n            }\r\n        })\r\n    }\r\n\r\n    // Throttle function from: https://lodash.com/docs/4.17.15#throttle\r\n    throttle (func, minWait, maxWait) {\r\n        let context, args, result\r\n        let timeout = null\r\n        let previous = 0\r\n        let previousScrollPosition = window.scrollY || window.scrollTop || document.getElementsByTagName('html')[0].scrollTop\r\n        let later = function () {\r\n            previous = new Date\r\n            previousScrollPosition = window.scrollY || window.scrollTop || document.getElementsByTagName('html')[0].scrollTop\r\n            timeout = null\r\n            result = func.apply(context, args)\r\n            if (!timeout) {\r\n                context = args = null\r\n            }\r\n        }\r\n        return function () {\r\n            let now = new Date\r\n            let currentScrollPosition = window.scrollY || window.scrollTop || document.getElementsByTagName('html')[0].scrollTop\r\n            let scrollDifference = Math.abs(currentScrollPosition - previousScrollPosition)\r\n            if (!previous) {\r\n                previous = now\r\n            }\r\n            let wait = minWait + (maxWait - minWait) * Math.exp(-scrollDifference)\r\n            let remaining = wait - (now - previous)\r\n            context = this\r\n            args = arguments\r\n            if (remaining <= 0 || remaining > wait) {\r\n                if (timeout) {\r\n                    clearTimeout(timeout)\r\n                    timeout = null\r\n                }\r\n                previous = now\r\n                previousScrollPosition = currentScrollPosition\r\n                result = func.apply(context, args)\r\n                if (!timeout) {\r\n                    context = args = null\r\n                }\r\n            } else if (!timeout) {\r\n                timeout = setTimeout(later, remaining)\r\n            }\r\n            return result\r\n        }\r\n    }\r\n\r\n    calculateSize (scrollPosition, minSize, maxSize, maxScroll) {\r\n        let newSize = maxSize - ((maxSize - minSize) * Math.min(1, scrollPosition / maxScroll))\r\n        // If newSize is within 1px of minSize or maxSize, return minSize or maxSize respectively.\r\n        if (Math.abs(newSize - minSize) < 1) {\r\n            return minSize\r\n        } else if (Math.abs(newSize - maxSize) < 5) {\r\n            return maxSize\r\n        } else {\r\n            return newSize\r\n        }\r\n    }\r\n\r\n    resize (newSize, operation) {\r\n        // Check if the new size is the same as the existing size\r\n        let existingSize = parseFloat(operation.targetElement.style[operation.propertyToResize])\r\n        if (existingSize !== newSize) {\r\n            operation.targetElement.style[operation.propertyToResize] = `${ newSize }${ operation.unit }`\r\n            // Add or remove the 'height-at-minimum' class depending on whether the new size is equal to minSize\r\n            if (newSize === operation.minSize) {\r\n                operation.targetElement.classList.add('height-at-minimum')\r\n            } else {\r\n                operation.targetElement.classList.remove('height-at-minimum')\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\n// Create an instance of the Header class and initialize the resize on scroll with the desired selector and parameters\r\n// let header = new Header();\r\n// header.resizeOnScroll('#site-header', 'max-height', '3.2rem', '11rem', 200, '0.1s ease-out 0s');\r\n\r\n// (function () {\r\n//     const element = document.getElementById('site-header');\r\n//\r\n//     // Get the initial height of the element\r\n//     const initialHeight = element.offsetHeight;\r\n//\r\n//     window.addEventListener('scroll', () => {\r\n//         // Get the current scroll position\r\n//         const scrollY = window.scrollY;\r\n//\r\n//         // Calculate the new height by subtracting the scroll position from the initial height\r\n//         const newHeight = Math.max(initialHeight - scrollY, 0); // Ensure it doesn't go negative\r\n//\r\n//         // Set the height of the element to the new height\r\n//         element.style.height = newHeight + 'px';\r\n//     });\r\n// })();\r\n\r\n// (function () {\r\n//     const element = document.getElementById('site-header');\r\n//\r\n//     // Get the value of the --header-max-height custom property\r\n//     const style = getComputedStyle(element);\r\n//     const initialHeight = parseInt(style.getPropertyValue('--header-max-height'), 10);\r\n//\r\n//     let isCollapsed = false;\r\n//\r\n//     window.addEventListener('scroll', () => {\r\n//         const scrollY = window.scrollY;\r\n//\r\n//         // Check if the user has scrolled down enough to trigger the animation\r\n//         if (scrollY >= initialHeight && !isCollapsed) {\r\n//             element.style.height = 'var(--header-min-height)';\r\n//             isCollapsed = true;\r\n//         } else if (scrollY < initialHeight && isCollapsed) {\r\n//             element.style.height = 'var(--header-max-height)';\r\n//             isCollapsed = false;\r\n//         }\r\n//     });\r\n// })();\r\n\r\n(function () {\r\n    const element = document.getElementById('site-header');\r\n\r\n    // Get the value of the --header-max-height custom property\r\n    const style = getComputedStyle(element);\r\n    const initialHeight = parseInt(style.getPropertyValue('--header-max-height'), 10);\r\n\r\n    let isCollapsed = false;\r\n\r\n    window.addEventListener('scroll', () => {\r\n        const scrollY = Math.floor(window.scrollY);\r\n\r\n        // Inform the browser that the height property will change, optimizing rendering\r\n        element.style.willChange = 'height';\r\n\r\n        // Check if the user has scrolled down enough to trigger the animation\r\n        if (scrollY >= initialHeight && !isCollapsed) {\r\n            element.style.height = 'var(--header-min-height)';\r\n            isCollapsed = true;\r\n        } else if (scrollY < initialHeight && isCollapsed) {\r\n            element.style.height = 'var(--header-max-height)';\r\n            isCollapsed = false;\r\n        }\r\n\r\n        // Optionally, you can reset willChange after the animation to release optimization resources\r\n        // setTimeout(() => { element.style.willChange = 'auto'; }, 300);\r\n    });\r\n})();\r\n\r\n"],"names":["window","addEventListener","document","querySelectorAll","forEach","container","ClassAccordion","constructor","focus","this","toggle","querySelector","content","button","init","findFirstFocusableElement","parentElement","focusableElements","visibleFocusableElements","Array","from","filter","el","offsetWidth","offsetHeight","length","checked","setAttribute","firstFocusableElement","element","getElementById","style","getComputedStyle","initialHeight","parseInt","getPropertyValue","isCollapsed","scrollY","Math","floor","willChange","height"],"mappings":"2FAAOA,OAAAC,iBAAiB,QAAQ,WACXC,SAASC,iBAAiB,cAElCC,SAAqBC,IAC9B,IAAIC,EAAeD,EAAS,GAEhC,IAGA,MAAMC,EACJC,YAAYF,EAAWG,GAAQ,GAC7BC,KAAKD,MAAQA,EACbC,KAAKJ,UAAYA,EACZI,KAAAC,OAASL,EAAUM,cAAc,WACjCF,KAAAG,QAAUP,EAAUM,cAAc,mBAClCF,KAAAI,OAASR,EAAUM,cAAc,iBACtCF,KAAKK,MACN,CAEDC,0BAA0BC,GACxB,MACMC,EAAoBD,EAAcb,iBADN,gKAE5Be,EAA2BC,MAAMC,KAAKH,GACLI,QAAaC,GAAAA,EAAGC,YAAc,GAAKD,EAAGE,aAAe,IAC5F,OAAON,EAAyBO,OAAS,EAAIP,EAAyB,GAAK,IAC5E,CAEDJ,OACOL,KAAAC,OAAOT,iBAAiB,UAAU,KACjC,GAAAQ,KAAKC,OAAOgB,SAId,GAFKjB,KAAAC,OAAOiB,aAAa,gBAAiB,QAEtClB,KAAKD,MAAO,CACd,IAAIoB,EAAwBnB,KAAKM,0BAA0BN,KAAKG,SAC5DgB,GACFA,EAAsBpB,OAEzB,OAGIC,KAAAC,OAAOiB,aAAa,gBAAiB,SAE1ClB,KAAKI,OAAOL,OACb,GAEJ,GCgHH,WACU,MAAAqB,EAAU3B,SAAS4B,eAAe,eAGlCC,EAAQC,iBAAiBH,GACzBI,EAAgBC,SAASH,EAAMI,iBAAiB,uBAAwB,IAE9E,IAAIC,GAAc,EAEXpC,OAAAC,iBAAiB,UAAU,KAC9B,MAAMoC,EAAUC,KAAKC,MAAMvC,OAAOqC,SAGlCR,EAAQE,MAAMS,WAAa,SAGvBH,GAAWJ,IAAkBG,GAC7BP,EAAQE,MAAMU,OAAS,2BACTL,GAAA,GACPC,EAAUJ,GAAiBG,IAClCP,EAAQE,MAAMU,OAAS,2BACTL,GAAA,EACjB,GAKL,CA3BJ"}